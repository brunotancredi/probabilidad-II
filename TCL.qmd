---
title: "Teorema del Límite Central"
date: today
date-format: DD-MM-YYYY[ ]
format: 
  revealjs:
    page-layout: full
editor: visual
---

## Repaso

Sea $X_1, X_2, \dots, X_n$ una sucesión de variables aleatorias i.i.d. con esperanza finita $\mu$ y varianza finita $\sigma^2$, y $\bar{X}_n = \frac{X_1 + X_2 + \dots + X_n}{n}$. 

Entonces, cuando $n \to \infty$,

$$
\mathbb{P} \left( \frac{\sqrt{n} (\bar{X}_n - \mu)}{\sigma} \leq x \right) \to \Phi(x) \quad \text{para todo } x \in \mathbb{R}
$$

## Ejercicio

Desarrollar el ejemplo 3, generando N= 100, 500, 1000 realizaciones de la sucesión del Error normalizado y construir histogramas/estimación de densidades con los 100, 500, 1000 valores obtenidos cuando M = 500 y 1000. Comparar los histogramas/estimación de densidades así obtenidos con la densidad de una distribución normal centrada con varianza igual a Var(U_1), U_1 \~ Uniforme(0,1). Interpretar los resultados obtenidos.

## Ejercicio - Solución para N = 1000

```{r, eval=F, echo=T}
N <- 100 
M <- 1000

semillas <- sample(1:10000,100,replace=F) #Obtenemos 1000 semillas

df <- do.call(rbind, lapply(semillas, genera_simulacion, M = M))
df <- df |> filter(M %in% c(1, 500, 1000))

ggplot(df) +
  geom_histogram(aes(x = normerror, y=after_stat(density)), fill = "blue") +
  labs(title = paste("Distribución de las medias muestrales"),
       x = "Media Muestral", y = "Frecuencia") +
  theme_minimal() +
  facet_wrap(~ M, nrow=2)
```

## Visualización TCL con U(0,1)

```{r, echo=F}
set.seed(123)

n_muestras <- 10000

data <- lapply(1:400, function(n){
  muestras <- matrix(runif(n*n_muestras), ncol = n_muestras, nrow = n)
  medias_muestrales <- apply(muestras, MARGIN = 2, mean)
  medias_muestrales_normalizadas <- (medias_muestrales - 0.5)*sqrt(n)/(sqrt(1/12))
})

data <- as.data.frame(data)
colnames(data) <- 1:400

ojs_define(ojs_data = data)
```

```{ojs}
//| panel: input
//| echo: False
//| width: "100%"
import { aq, op } from '@uwdata/arquero'

my_data = aq.from(transpose(ojs_data))

viewof n = Inputs.range(
  [1, 400], 
  {value: 1, step: 1, label: "Tamaño muestra:"}
)

normalData = Array.from({ length: 100 }, (_, i) => {
  let x = -3 + (i / 99) * 6; // Range from -3 to 3
  return { x, y: Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI) };
});

point = Array.from({length: 1}, (_, i) => {return {x: 0, y: 0.5}})

Plot.plot({
    width: 1000,
    height: 500,
    y: {grid: true},
    x: {round: true},    
    marks: [
      Plot.rectY(my_data, 
                Plot.binX({y: (a, bin) => {
                              return a.length / (10000*(bin.x2 - bin.x1));
                           }}, 
                          {x: {value: n.toString(), 
                               inset: 0,
                               thresholds: d3.range(-3,3 + 0.11, 0.11),
                               domain: [-3, 3],
                               }})),
      Plot.ruleY([0]),
      Plot.line(normalData, { x: "x", y: "y", stroke: "red" }), //Normal
      Plot.dot(point, {x: "x", y: "y", r: 0})    
    ]
})
```

## Recomendación

{{< video https://www.youtube.com/watch?v=zeJD6dqJ5lo width="100%" height="85%" >}}
